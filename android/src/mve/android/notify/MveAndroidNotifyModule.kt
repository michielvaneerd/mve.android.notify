/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * TiDev Titanium Mobile
 * Copyright TiDev, Inc. 04/07/2022-Present
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */

package mve.android.notify

import android.app.AlarmManager
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import java.util.Calendar
import android.os.Build
import androidx.annotation.RequiresApi
import org.appcelerator.kroll.KrollModule
import org.appcelerator.kroll.KrollDict
import org.appcelerator.kroll.annotations.Kroll
import org.appcelerator.kroll.common.TiConfig
import org.appcelerator.titanium.TiApplication
import java.text.SimpleDateFormat

const val channelId = "channel";
val DBG = TiConfig.LOGD
const val LCAT = "MveAndroidNotifyModule"

@Kroll.module(name = "MveAndroidNotify", id = "mve.android.notify")
class MveAndroidNotifyModule: KrollModule() {

	// NOTE: You can develop Titanium Android modules in Android Studio. Follow these three steps:
	//   1. Build the empty module
	//   2. Drag the "build" folder into Android Studio
	//   3. Start developing! All dependencies and code completions are supported!

	companion object {

		const val NOTIFICATION_REQUEST_CODE = "requestCode"
		const val NOTIFICATION_CONTENT = "content"
		const val NOTIFICATION_TITLE = "title"
		const val NOTIFICATION_ICON = "icon"
		const val NOTIFICATION_HOUR = "hour"
		const val NOTIFICATION_MINUTE = "minute"
		const val NOTIFICATION_INTERVAL = "interval"
		const val NOTIFICATION_INTERVAL_ONCE = "once"
		const val NOTIFICATION_INTERVAL_FIFTEEN_MINUTES = "15_min"
		const val NOTIFICATION_INTERVAL_HALF_HOUR = "half_hour"
		const val NOTIFICATION_INTERVAL_HOUR = "hour"
		const val NOTIFICATION_INTERVAL_DAY = "day"
		const val NOTIFICATION_INTERVAL_WEEK = "week"
		const val NOTIFICATION_INTERVAL_4_WEEK = "4_week"
		const val NOTIFICATION_EXACT = "exact"

		
		// You can define constants with @Kroll.constant, for example:
		// @Kroll.constant private val EXTERNAL_NAME = "EXTERNAL_NAME"

		@Kroll.onAppCreate
		fun onAppCreate(app: TiApplication?) {

		}


	}

	@Kroll.method
	fun createChannel() {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
			Utils.log("Create notification channel")
			val name: CharSequence = "default";
			val notificationChannel = NotificationChannel(channelId, name, NotificationManager.IMPORTANCE_DEFAULT)
			val notificationManager = TiApplication.getInstance().applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
			notificationManager.createNotificationChannel(notificationChannel)
		}
	}



	@Kroll.method
	fun cancel(requestCode: Int) {
		Utils.log("Cancelling notification $requestCode")
		val alarmManager = TiApplication.getInstance().applicationContext.getSystemService(Context.ALARM_SERVICE) as AlarmManager;
		alarmManager.cancel(getPendingIntent(requestCode, getReceiverIntent()));
	}

	@Kroll.method
	fun schedule(arg: KrollDict) {

		val requestCode = arg.getInt(NOTIFICATION_REQUEST_CODE)
		val title = arg.getString(NOTIFICATION_TITLE)
		val content = arg.getString(NOTIFICATION_CONTENT)
		val icon = arg.getString(NOTIFICATION_ICON)
		val hour = arg.getInt(NOTIFICATION_HOUR)
		val minute = arg.getInt(NOTIFICATION_MINUTE)
		val interval = if (arg.containsKeyAndNotNull(NOTIFICATION_INTERVAL)) arg.getString(NOTIFICATION_INTERVAL) else NOTIFICATION_INTERVAL_ONCE

		val intervalInMs = when (interval) {
			NOTIFICATION_INTERVAL_FIFTEEN_MINUTES -> AlarmManager.INTERVAL_FIFTEEN_MINUTES
			NOTIFICATION_INTERVAL_HALF_HOUR -> AlarmManager.INTERVAL_HALF_HOUR
			NOTIFICATION_INTERVAL_HOUR -> AlarmManager.INTERVAL_HOUR
			NOTIFICATION_INTERVAL_DAY -> AlarmManager.INTERVAL_DAY
			NOTIFICATION_INTERVAL_WEEK -> AlarmManager.INTERVAL_DAY * 7
			NOTIFICATION_INTERVAL_4_WEEK -> AlarmManager.INTERVAL_DAY * 28
			else -> 0L
		}
		val isExact = arg.getBoolean(NOTIFICATION_EXACT)

		val context = TiApplication.getInstance().applicationContext;

		var infoIntent = getReceiverIntent();
		infoIntent.putExtra(NOTIFICATION_REQUEST_CODE, requestCode)
		infoIntent.putExtra(NOTIFICATION_CONTENT, content)
		infoIntent.putExtra(NOTIFICATION_TITLE, title)
		infoIntent.putExtra(NOTIFICATION_ICON, icon)
		infoIntent.putExtra(NOTIFICATION_INTERVAL, interval)
		infoIntent.putExtra(NOTIFICATION_EXACT, isExact)
		infoIntent.putExtra(NOTIFICATION_HOUR, hour)
		infoIntent.putExtra(NOTIFICATION_MINUTE, minute)

		val calendar: Calendar = Calendar.getInstance().apply {
			timeInMillis = System.currentTimeMillis()
			set(Calendar.HOUR_OF_DAY, hour)
			set(Calendar.MINUTE, minute)
		}

		val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager;
		var pendingIntent = getPendingIntent(requestCode, infoIntent)

		// setRepeating doesn't work exact, you have to schedule one exact with setExact() and then reschedule the next one in the alarm receiver.
		// https://stackoverflow.com/a/59473739/1294832

		if (isExact) {
			if (interval == NOTIFICATION_INTERVAL_ONCE) {
				alarmManager.setExact(AlarmManager.RTC_WAKEUP, calendar.timeInMillis, pendingIntent)
			} else {
				alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, calendar.timeInMillis, intervalInMs, pendingIntent)
			}
		} else {
			if (interval == NOTIFICATION_INTERVAL_ONCE) {
				alarmManager.set(AlarmManager.RTC_WAKEUP, calendar.timeInMillis, pendingIntent)
			} else {
				alarmManager.setInexactRepeating(
					AlarmManager.RTC_WAKEUP,
					calendar.timeInMillis,
					intervalInMs,
					pendingIntent
				)
			}
		}

		Utils.log("Scheduled $interval " + (if(isExact) " exact " else " inexact ") + " notification with id $requestCode starting on ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(calendar.time)}")
	}

	@Kroll.method
	fun canScheduleExactAlarms(): Boolean {
		val alarmManager = TiApplication.getInstance().applicationContext.getSystemService(Context.ALARM_SERVICE) as AlarmManager;
		return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) alarmManager.canScheduleExactAlarms() else true;
	}

	private fun getReceiverIntent(): Intent {
		return Intent(TiApplication.getInstance().applicationContext, MveAlarmReceiver::class.java)
	}

	private fun getPendingIntent(requestCode: Int, intent: Intent): PendingIntent {
		return PendingIntent.getBroadcast(TiApplication.getInstance().applicationContext, requestCode, intent,
			PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
	}
}
