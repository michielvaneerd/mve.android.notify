/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * TiDev Titanium Mobile
 * Copyright TiDev, Inc. 04/07/2022-Present
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */

package mve.android.notify

import android.Manifest
import android.app.AlarmManager
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.icu.util.Calendar
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import org.appcelerator.kroll.KrollModule
import org.appcelerator.kroll.KrollDict
import org.appcelerator.kroll.annotations.Kroll
import org.appcelerator.kroll.common.Log
import org.appcelerator.kroll.common.TiConfig
import org.appcelerator.titanium.TiApplication
import org.appcelerator.titanium.util.TiRHelper

const val channelId = "channel";

@Kroll.module(name = "MveAndroidNotify", id = "mve.android.notify")
class MveAndroidNotifyModule: KrollModule() {

	// NOTE: You can develop Titanium Android modules in Android Studio. Follow these three steps:
	//   1. Build the empty module
	//   2. Drag the "build" folder into Android Studio
	//   3. Start developing! All dependencies and code completions are supported!

	companion object {
		// Standard Debugging variables
		private const val LCAT = "MveAndroidNotifyModule"
		private val DBG = TiConfig.LOGD

		const val NOTIFICATION_REQUEST_CODE = "requestCode"
		const val NOTIFICATION_CONTENT = "content"
		const val NOTIFICATION_TITLE = "title"
		const val NOTIFICATION_ICON = "icon"
		
		// You can define constants with @Kroll.constant, for example:
		// @Kroll.constant private val EXTERNAL_NAME = "EXTERNAL_NAME"

		@Kroll.onAppCreate
		fun onAppCreate(app: TiApplication?) {
			Log.d(LCAT, "inside onAppCreate")
			// put module init code that needs to run when the application is created
		}
	}

	@Kroll.method
	fun createChannel() {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
			Log.d(LCAT, "Creating channel")
			val name: CharSequence = "default";
			val notificationChannel = NotificationChannel(channelId, name, NotificationManager.IMPORTANCE_DEFAULT)
			val notificationManager = TiApplication.getInstance().applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
			notificationManager.createNotificationChannel(notificationChannel)
		}
	}

//	@Kroll.method
//	fun showNotification() {
//		android.util.Log.d(LCAT, "Build notification!")
//		val builder = NotificationCompat.Builder(TiApplication.getInstance().applicationContext, channelId)
//			.setSmallIcon(TiRHelper.getApplicationResource("drawable.ic_stat_capsules_solid"))
//			.setContentTitle("Dit is een title!")
//			.setContentText("Dit is de content!")
//			.setContentIntent(createIntent())
//			.setAutoCancel(true)
//		android.util.Log.d(LCAT, "Build notification OK!")
//		if (ActivityCompat.checkSelfPermission(
//				TiApplication.getInstance().applicationContext,
//				Manifest.permission.POST_NOTIFICATIONS
//			) != PackageManager.PERMISSION_GRANTED
//		) {
//			android.util.Log.d(LCAT, "No permission...")
//			// TODO: Consider calling
//			//    ActivityCompat#requestPermissions
//			// here to request the missing permissions, and then overriding
//			//   public void onRequestPermissionsResult(int requestCode, String[] permissions,
//			//                                          int[] grantResults)
//			// to handle the case where the user grants the permission. See the documentation
//			// for ActivityCompat#requestPermissions for more details.
//			return
//		}
//		NotificationManagerCompat.from(TiApplication.getInstance()).notify(1, builder.build())
//		android.util.Log.d(LCAT, "You should see a notification!!")
//
//	}

	private fun createIntent() : PendingIntent
	{
		//val launchIntent = TiApplication.getInstance().applicationContext.packageManager.getLaunchIntentForPackage(TiApplication.getInstance().applicationContext.packageName)
		//return PendingIntent.getActivity(TiApplication.getInstance().applicationContext, 1, launchIntent,   PendingIntent.FLAG_IMMUTABLE);
		val launchIntent = TiApplication.getInstance().applicationContext.packageManager
			.getLaunchIntentForPackage(TiApplication.getInstance().applicationContext.packageName)
		if (launchIntent != null) {
			launchIntent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_SINGLE_TOP
			launchIntent.addCategory(Intent.CATEGORY_LAUNCHER)
			launchIntent.action = Intent.ACTION_MAIN
		}
		return PendingIntent.getActivity(TiApplication.getInstance().applicationContext, 1,
			launchIntent!!, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE) as PendingIntent
	}

	@RequiresApi(Build.VERSION_CODES.N)
	@Kroll.method
	fun schedule(title: String, content: String, hour: Int, minute: Int, requestCode: Int, icon: String) {

		// MOet gedaan worden door de Ti app!
		//createChannel()

		val context = TiApplication.getInstance().applicationContext;

		var infoIntent = Intent(context, MveAlarmReceiver::class.java)
		infoIntent.putExtra(NOTIFICATION_REQUEST_CODE, requestCode)
		infoIntent.putExtra(NOTIFICATION_CONTENT, content)
		infoIntent.putExtra(NOTIFICATION_TITLE, title)
		infoIntent.putExtra(NOTIFICATION_ICON, icon)

		Log.d(LCAT, "Scheduling for $content and code = $requestCode")

		val calendar: Calendar = Calendar.getInstance().apply {
			timeInMillis = System.currentTimeMillis() + 5000 // dus 5 seconden na nu inplannen
			//set(Calendar.HOUR_OF_DAY, 16)
		}

		var alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager;
		var pendingIntent = PendingIntent.getBroadcast(context, requestCode, infoIntent,
			PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
		alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, calendar.timeInMillis, AlarmManager.INTERVAL_DAY, pendingIntent)

		Log.d(LCAT, "Method schedule() called with $title and $content and requestCode = $requestCode and hour $hour and $minute op ${calendar.get(Calendar.HOUR_OF_DAY)}:${calendar.get(Calendar.MINUTE)}!")
	}
	
//	@Kroll.method
//	fun testMethod(params: KrollDict) {
//		Log.d(LCAT, "testMethod() called")
//
//		// Access the parameters passed as an Object, e.g. "myModule.testMethod({ name: 'John Doe', flag: true })"
//		val name = params.getString("name")
//		val flag = params.optBoolean("flag", false)
//
//		// Fire an event that can be added via "myModule.addEventListener('shown', ...)"
//		val event = KrollDict()
//		event["name"] = name
//		event["flag"] = flag
//
//		fireEvent("", event)
//	}

	// Properties

//	@get:Kroll.getProperty
//	@set:Kroll.setProperty
//	var exampleProp: String
//		get() {
//			Log.d(LCAT, "get example property")
//			return "hello world"
//		}
//		set(value) {
//			Log.d(LCAT, "set example property: $value")
//		}
}
